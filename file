[package]
name = "ciphers"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
encoding_rs = "0.8.32"
itertools = "0.11.0"
num = "0.4.1"
regex = "1.9.3"
rust-argon2 = "1.0.1"
serde = { version = "1.0.183", features = ["derive"] }
serde_json = "1.0.104"
unicode-segmentation = "1.10.1"use regex::Regex;
use unicode_segmentation::UnicodeSegmentation;

use crate::error::Error;
use crate::traits::SwitchCase;
use crate::utils::{get_char_by_index, modulus, EN_ALP, RU_ALP, RU_ALP_WITH_YO};

pub trait VigenereCipher {
    fn cipher<F>(lang: &str, params: &Vec<String>, input: &str, f: F) -> Result<String, Error>
    where
        F: Fn(i16, i16) -> i16,
    {
        <Self as VigenereCipher>::validate_language(lang, params, input)?;

        let (alp, reg) = match lang {
            "en" => EN_ALP,
            "ru" => RU_ALP,
            "ru_with_yo" => RU_ALP_WITH_YO,
            _ => unreachable!(),
        };

        let mut map = std::collections::HashMap::new();
        for (k, v) in alp.chars().enumerate() {
            map.insert(v, k);
        }

        let key = &params[0].to_lowercase();
        let rg = Regex::new(reg).unwrap();
        let mut index = 0usize;
        let mut cipher_text = String::new();

        let key_len = key.graphemes(true).count();
        let alp_len = alp.graphemes(true).count() as i16;

        for c in input.chars() {
            if !rg.is_match(&c.to_string()) {
                cipher_text.push(c);
                continue;
            }

            let key_idx = map
                .get(&get_char_by_index(key, index % key_len))
                .unwrap()
                .to_owned() as i16;

            let text_idx = match c.is_lowercase() {
                true => map.get(&c).unwrap(),
                false => map.get(&c.to_lower_case()).unwrap(),
            }
            .to_owned() as i16;

            let idx = f(text_idx, key_idx);

            cipher_text.push(match c.is_lowercase() {
                true => get_char_by_index(alp, modulus(idx, alp_len)),
                false => get_char_by_index(alp, modulus(idx, alp_len)).to_upper_case(),
            });

            index += 1;
        }

        Ok(cipher_text)
    }

    fn validate_language(lang: &str, params: &Vec<String>, input: &str) -> Result<(), Error> {
        if input.is_empty() {
            return Err(Error::InvalidInputError {
                error: "Input is empty".to_string(),
            });
        }

        let langs = ["en", "ru", "ru_with_yo"];

        if !langs.contains(&lang) {
            return Err(Error::UnsupportedLanguageError {
                error: "Unsupported language.".to_string(),
            });
        }

        if params.len() != 1 {
            return Err(Error::InvalidNumberOfParamsError {
                error: "Invalid number of params error.".to_string(),
            });
        }

        let reg = match lang {
            "en" => Regex::new(EN_ALP.1).unwrap(),
            "ru" => Regex::new(RU_ALP.1).unwrap(),
            "ru_with_yo" => Regex::new(RU_ALP_WITH_YO.1).unwrap(),
            _ => {
                return Err(Error::UnsupportedLanguageError {
                    error: "Unsupported language.".to_string(),
                })
            }
        };

        if !reg.is_match(&params[0]) {
            return Err(Error::IvalidKeyError {
                error: "invalid key.".to_string(),
            });
        }

        Ok(())
    }
}
// pub mod vigenere_trait;
pub mod a1z26cipher_decode_mod;
pub mod a1z26cipher_encode_mod;
pub mod affine_cipher_decode_mod;
pub mod affine_cipher_encode_mod;
pub mod analyse_hash_mod;
pub mod argon2_mod;
// pub mod from_base64_mod;
// pub mod to_base64_mod;
// pub mod vigenere_cipher_decode_mod;
// pub mod vigenere_cipher_encode_mod;
use crate::error::Error;
use crate::utils::to_base64;
use common::{create_operation_struct, Operation};

create_operation_struct!(ToBase64);

impl Operation for ToBase64 {
    fn new(lang: String, params: Vec<String>, input: String) -> Self {
        ToBase64 {
            name: "To Base64",
            module: "Default",
            description_en: Some("Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation encodes raw data into an ASCII Base64 string.<br><br>e.g. <code>hello</code> becomes <code>aGVsbG8=</code>"),
            description_ru: Some("Base64 — это нотация для кодирования произвольных байтовых данных с использованием ограниченного набора символов, которые могут удобно использоваться людьми и обрабатываться компьютерами.<br><br>Эта операция кодирует необработанные данные в строку ASCII Base64.<br><br>Например: <code>привет</code> becomes <code>h/ECHEMoaxC</code>"),
            info_url: Some("https://wikipedia.org/wiki/Base64"),
            lang,
            params,
            input,
        }
    }

    fn run(&self) -> Result<String, Error> {
        self.validate()?;
        to_base64(&self.input, &self.params[0])
    }

    fn validate(&self) -> Result<(), Error> {
        if self.params.len() != 1 {
            return Err(Error::InvalidNumberOfParamsError {
                error: "Invalid number of params.".to_string(),
            });
        }

        Ok(())
    }
}
use crate::error::Error;
use crate::utils::{from_base64, DataRepresentation};
use common::{create_operation_struct, Operation};

create_operation_struct!(FromBase64);

impl Operation for FromBase64 {
    fn new(lang: String, params: Vec<String>, input: String) -> Self {
        FromBase64 {
            name: "From Base64",
            module: "Default",
            description_en: Some("Base64 is a notation for encoding arbitrary byte data using a restricted set of symbols that can be conveniently used by humans and processed by computers.<br><br>This operation decodes raw data into an ASCII Base64 string.<br><br>e.g. <code>aGVsbG8=</code> becomes <code>hello</code>"),
            description_ru: Some("Base64 — это нотация для кодирования произвольных байтовых данных с использованием ограниченного набора символов, которые могут удобно использоваться людьми и обрабатываться компьютерами.<br><br>Эта операция декодирует необработанные данные в строку ASCII Base64.<br><br>e.g. <code>h/ECHEMoaxC</code> становиться <code>привет</code>"),
            info_url: Some("https://wikipedia.org/wiki/Base64"),
            lang,
            params,
            input
        }
    }

    fn run(&self) -> Result<String, Error> {
        self.validate()?;

        match from_base64(
            self.input.clone(),
            &self.params[0],
            DataRepresentation::String(String::new()),
            matches!(&*self.params[1], "true"),
            matches!(&*self.params[1], "true"),
        ) {
            Ok(output) => {
                let DataRepresentation::String(output) = output else {
                    unreachable!()
                };
                Ok(output.trim_end_matches('\0').to_string())
            }
            Err(e) => Err(e),
        }
    }

    fn validate(&self) -> Result<(), Error> {
        if self.params.len() != 3 {
            return Err(Error::InvalidNumberOfParamsError {
                error: "Invalid number of params.".to_string(),
            });
        }

        Ok(())
    }
}
use crate::error::Error;
use crate::libs::vigenere_trait::VigenereCipher;
use crate::utils::sub;
use common::{create_operation_struct, Operation};

create_operation_struct!(VigenereCipherDecode);

impl VigenereCipher for VigenereCipherDecode {}

impl Operation for VigenereCipherDecode {
    fn new(lang: String, params: Vec<String>, input: String) -> Self {
        VigenereCipherDecode {
            name: "Vigenere Decode",
            module: "Cipher",
            description_en: Some("The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution."),
            description_ru: Some("Шифр Виженера — это метод шифрования алфавитного текста с использованием ряда различных общих символов Цезаря, основанных на буквах ключевого слова. Это простая форма полиалфавитной замены."),
            info_url: Some("https://wikipedia.org/wiki/Vigenère_cipher"),
            lang,
            params,
            input
        }
    }

    fn run(&self) -> Result<String, Error> {
        <Self as VigenereCipher>::cipher(&self.lang, &self.params, &self.input, sub)
    }

    fn validate(&self) -> Result<(), Error> {
        Ok(())
    }
}
use crate::error::Error;
use crate::libs::vigenere_trait::VigenereCipher;
use crate::utils::add;
use common::{create_operation_struct, Operation};

create_operation_struct!(VigenereCipherEncode);

impl VigenereCipher for VigenereCipherEncode {}

impl Operation for VigenereCipherEncode {
    fn new(lang: String, params: Vec<String>, input: String) -> Self {
        VigenereCipherEncode {
            name: "Vigenere Encode",
            module: "Cipher",
            description_en: Some("The Vigenere cipher is a method of encrypting alphabetic text by using a series of different Caesar common based on the letters of a keyword. It is a simple form of polyalphabetic substitution."),
            description_ru: Some("Шифр Виженера — это метод шифрования алфавитного текста с использованием ряда различных общих символов Цезаря, основанных на буквах ключевого слова. Это простая форма полиалфавитной замены."),
            info_url: Some("https://wikipedia.org/wiki/Vigenère_cipher"),
            lang,
            params,
            input
        }
    }

    fn run(&self) -> Result<String, Error> {
        <Self as VigenereCipher>::cipher(&self.lang, &self.params, &self.input, add)
    }

    fn validate(&self) -> Result<(), Error> {
        Ok(())
    }
}
use crate::{create_info_struct, Operation, DOCS_URL};
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, SerializeMeDaddy> for AnalyseHash {
    fn run(&self, request: &str) -> Result<SerializeMeDaddy, String> {
        let request = self.validate(request)?;
        let input = request
            .input
            .chars()
            .map(|x| match x {
                '\t' | '\n' | ' ' => "".to_string(),
                _ => x.to_string(),
            })
            .collect::<String>();

        let hash_length = input.len();
        let byte_length: f64 = hash_length as f64 / 2.0;
        let bit_length: f64 = byte_length * 8.0;

        let possible_hash_functions = match bit_length as u16 {
            4 => vec!["Fletcher-4", "Luhn algorithm", "Verhoeff algorithm"],
            8 => vec!["Fletcher-8"],
            16 => vec!["BSD checksum", "CRC-16", "SYSV checksum", "Fletcher-16"],
            32 => vec!["CRC-32", "Fletcher-32", "Adler-32"],
            64 => vec!["CRC-64", "RIPEMD-64", "SipHash"],
            128 => vec![
                "MD5",
                "MD4",
                "MD2",
                "HAVAL-128",
                "RIPEMD-128",
                "Snefru",
                "Tiger-128",
            ],
            160 => vec![
                "SHA-1",
                "SHA-0",
                "FSB-160",
                "HAS-160",
                "HAVAL-160",
                "RIPEMD-160",
                "Tiger-160",
            ],
            192 => vec!["Tiger", "HAVAL-192"],
            224 => vec!["SHA-224", "SHA3-224", "ECOH-224", "FSB-224", "HAVAL-224"],
            256 => vec![
                "SHA-256",
                "SHA3-256",
                "BLAKE-256",
                "ECOH-256",
                "FSB-256",
                "GOST",
                "Grøstl-256",
                "HAVAL-256",
                "PANAMA",
                "RIPEMD-256",
                "Snefru",
            ],
            320 => vec!["RIPEMD-320"],
            384 => vec!["SHA-384", "SHA3-384", "ECOH-384", "FSB-384"],
            512 => vec![
                "SHA-512",
                "SHA3-512",
                "BLAKE-512",
                "ECOH-512",
                "FSB-512",
                "Grøstl-512",
                "JH",
                "MD6",
                "Spectral Hash",
                "SWIFFT",
                "Whirlpool",
            ],
            1024 => vec!["Fowler-Noll-Vo"],
            _ => {
                vec!["Unknown"]
            }
        };

        Ok(SerializeMeDaddy {
            hash_length,
            byte_length,
            bit_length,
            possible_hash_functions,
        })
    }
}

#[derive(Serialize)]
pub struct SerializeMeDaddy {
    hash_length: usize,
    byte_length: f64,
    bit_length: f64,
    possible_hash_functions: Vec<&'static str>,
}

#[derive(Deserialize)]
pub struct DeserializeMeDaddy {
    input: String,
}

pub struct AnalyseHash;

const NAME: &str = "AnalyseHash";
const DESCRIPTION_EN: &str = "Tries to determine information about a given hash and suggests which algorithm may have been used to generate it based on its length.";
const DESCRIPTION_RU: &str = "Пытается определить информацию о заданном хэше и предлагает, какой алгоритм мог быть использован для его генерации, исходя из его длины.";
const INFO_URL: Option<&str> =
    Some("https://wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions");

create_info_struct!(
    AnalyseHashInfo,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
use crate::{
    create_info_struct, create_me_daddy, regex_check, utils::char_repr, Operation, DOCS_URL,
};
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, String> for A1Z26CipherDecode {
    fn run(&self, request: &str) -> Result<String, String> {
        let request = self.validate(request)?;

        let delimiter = char_repr(&request.params.delimiter);

        let cipher_text = request
            .input
            .trim_matches(|c: char| [delimiter].contains(&&*c.to_string()))
            .split(delimiter);

        let mut plain_text = String::new();

        for c in cipher_text {
            let c = c.parse::<u8>().unwrap();
            if !(1..=26).contains(&c) {
                return Err("All numbers must be between 1 and 26.".to_string());
            }
            plain_text.push((c + 96) as char);
        }
        Ok(plain_text)
    }

    fn validate(&self, request: &str) -> Result<DeserializeMeDaddy, String> {
        let request = self.deserialize(request)?;

        let regex_checked = match &*request.params.delimiter {
            "Space" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6]) ?)+\s*$" => &request.input)
            }
            "Comma" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6]),?)+\s*$" => &request.input)
            }
            "Semi-colon" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6]);?)+\s*$" => &request.input)
            }
            "Colon" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6]):?)+\s*$" => &request.input)
            }
            "Line feed" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6])\n?)+\s*$" => &request.input)
            }
            "CRLF" => {
                regex_check!(r"^\s*(([1-9]|1[0-9]|2[0-6])\r\n?)+\s*$" => &request.input)
            }
            _ => false,
        };
        if !regex_checked {
            return Err(format!(
                "Invalid delimiter: `{delimiter}`",
                delimiter = request.params.delimiter
            ));
        }

        Ok(request)
    }
}
#[derive(Deserialize)]
struct Params {
    delimiter: String,
}

create_me_daddy!();

/// A1Z26 is a simple substitution cipher where each letter is replaced by its serial number in the alphabet.
/// <br/><br/>
/// ### How to use
/// \
/// Send POST requests to /api/A1Z26CipherDecode with your data using json payload with this structure
/// ``` json
/// {
///     "input": string,
///     "params": {
///         "delimiter": string
///     }
/// }
/// ```
/// #### where
///     - delimiter is one of "Space", "Comma", "Semi-colon", "Colon", "Line feed", "CRLF"
/// <br/><br/>
///
/// ### Server response have two possible formats
///
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
/// ``` json
/// { "Ok": `some answer` }
/// ```
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
/// ``` json
/// { "Err": `error message` }
/// ```
/// ### Examples
/// <br><br/>
/// #### №1
/// ``` http
/// POST /api/A1Z26CipherDecode
///
/// {
///     "input": "8 5 12 12 15",
///     "params": {
///         "delimiter": "Space"
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 200 Ok
/// {
///   "Ok": "hello"
/// }
/// ```
/// #### №2
/// ``` http
/// POST /api/A1Z26CipherDecode
///
/// {
///     "input": "18;9;3;11;18;15;12;12",
///     "params": {
///         "delimiter": "Semi-colon"
///     }
/// }
/// ```
/// ```http
/// {
///   "Ok": "rickroll"
/// }
/// ```
/// #### №3
/// ``` http
/// POST /api/A1Z26CipherDecode
///
/// {
///     "input": "4 1 21 15 3",
///     "params": {
///         "delimiter": "Unsupported delimiter"
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 400 Bad Request
/// {
///   "Err": "Invalid delimiter: `Unsupported delimiter`"
/// }
/// ```

pub struct A1Z26CipherDecode;

const NAME: &str = "A1Z26CipherDecode";
const DESCRIPTION_EN: &str =
    "Converts alphabet order numbers into their corresponding alphabet character.";
const DESCRIPTION_RU: &str =
    "Преобразует порядковые номера алфавита в соответствующие им символы алфавита.";

const INFO_URL: Option<&str> = None;

create_info_struct!(
    A1Z26CipherDecodeInfo,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
use crate::{create_info_struct, create_me_daddy, utils::char_repr, Operation, DOCS_URL};
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, String> for A1Z26CipherEncode {
    fn run(&self, request: &str) -> Result<String, String> {
        let request = self.validate(request)?;

        let mut result = String::new();
        let delimiter = char_repr(&request.params.delimiter);

        for character in request.input.chars() {
            result.push_str(&match character {
                'a'..='z' => format!("{}{}", character as u8 - 96, delimiter),
                'A'..='Z' => format!("{}{}", character as u8 - 64, delimiter),
                _ => "".to_string(),
            });
        }
        if result.is_empty() {
            return Ok(String::new());
        }
        Ok(result[..result.len() - 1].to_string())
    }
}

#[derive(Deserialize)]
struct Params {
    delimiter: String,
}

create_me_daddy!();

/// A1Z26 is a simple substitution cipher where each letter is replaced by its serial number in the alphabet.
/// <br/><br/>
/// ### How to use
/// \
/// Send POST requests to /api/A1Z26CipherEncode with your data using json payload with this structure
/// ``` json
/// {
///     "input": string,
///     "params": {
///         "delimiter": string
///     }
/// }
/// ```
/// #### where
///     - delimiter is one of "Space", "Comma", "Semi-colon", "Colon", "Line feed", "CRLF"
/// <br/><br/>
///
/// ### Server response have two possible formats
///
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
/// ``` json
/// { "Ok": `some answer` }
/// ```
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
/// ``` json
/// { "Err": `error message` }
/// ```
/// ### Examples
/// <br><br/>
/// #### №1
/// ``` http
/// POST /api/A1Z26CipherEncode
///
/// {
///     "input": "hello",
///     "params": {
///         "delimiter": "Space"
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 200 Ok
/// {
///   "Ok": "8 5 12 12 15"
/// }
/// ```
/// #### №2
/// ``` http
/// POST /api/A1Z26CipherDecode
///
/// {
///     "input": "18;9;3;11;18;15;12;12",
///     "params": {
///         "delimiter": "Semi-colon"
///     }
/// }
/// ```
/// ```http
/// {
///   "Ok": "rickroll"
/// }
/// ```
/// #### №3
/// ``` http
/// POST /api/A1Z26CipherDecode
///
/// {
///     "input": "4 1 21 15 3",
///     "params": {
///         "delimiter": "Unsupported delimiter"
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 400 Bad Request
/// {
///   "Err": "Invalid delimiter: `Unsupported delimiter`."
/// }
/// ```

pub struct A1Z26CipherEncode;

const NAME: &str = "A1Z26CipherEncode";
const DESCRIPTION_EN: &str =
    "Converts alphabet characters into their corresponding alphabet order number.";
const DESCRIPTION_RU: &str =
    "Преобразует символы алфавита в соответствующие им порядковые номера алфавита.";

const INFO_URL: Option<&str> = None;

create_info_struct!(
    A1Z26CipherEncodeInfo,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
use crate::utils::modulus;
use crate::{
    create_info_struct, lang_me_daddy,
    traits::CharTrait,
    utils::{get_alphabet, get_char_by_index, get_index_by_char, mod_inv, validate_lang},
    Operation, DOCS_URL,
};
use num::Integer;
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, String> for AffineCipherDecode {
    fn run(&self, request: &str) -> Result<String, String> {
        let request = self.validate(request)?;

        let (input, lang, params) = (request.input, request.lang, request.params);
        if !validate_lang(&input, &lang) {
            return Err("Wrong language.".to_string());
        };

        let (a, b) = (params.a as i16, params.b as i16);

        let (alp_lower, alp_upper, alp_length, _) = get_alphabet(&lang);
        if a.gcd(&(alp_length as i16)) != 1 {
            return Err(format!(
                "The value of `a` must be coprime to alphabet length({}).",
                alp_length
            ));
        }

        let mut output = String::with_capacity(alp_length as usize);

        for c in input.chars() {
            if !c.is_alphabetic() {
                output.push(c);
                continue;
            }

            let y = match c.is_lowercase() {
                true => get_index_by_char(alp_lower, c),
                false => get_index_by_char(alp_upper, c),
            } as i16;

            let inv_a = mod_inv(a, alp_length as i16);

            let x = modulus(inv_a * (y - b), alp_length as i16);

            output.push(match c.is_lowercase() {
                true => get_char_by_index(alp_lower, x),
                false => get_char_by_index(alp_upper, x).to_upper_case(),
            });
        }

        Ok(output)
    }
}

#[derive(Deserialize)]
struct Params {
    a: u8,
    b: u8,
}

lang_me_daddy!();

/// The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.
/// <br><br/>
/// For more information go [here](https://wikipedia.org/wiki/Argon2)
/// <br><br/>
/// ### How to use
/// \
/// Send POST requests to /api/AffineCipherDecode with your data using json payload with this structure
/// ``` json
/// {
///     "input": string,
///     "params": {
///         "a": u8,
///         "b": u8,
///     }
/// }
/// ```
/// #### where
///     - u8 is unsigned 8-bit integer (digit between 0 and 255)
/// <br/><br/>
///
/// ### Server response have two possible formats
///
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
/// ``` json
/// { "Ok": `some answer` }
/// ```
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
/// ``` json
/// { "Err": `error message` }
/// ```
/// ### Examples
/// <br><br/>
/// #### №1
/// ``` http
/// POST /api/AffineCipherDecode
///
/// {
///     "input": "Cnwwl, Zlawi!",
///     "lang": "en",
///     "params": {
///         "a": 5,
///         "b": 19
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 200 Ok
/// {
///   "Ok": "Hello, World!"
/// }
/// ```
/// #### №2
/// ``` http
/// POST /api/AffineCipherDecode
///
/// {
///     "input": "Мскньы, Юкс!",
///     "params": {
///         "a": 5,
///         "b" 3,
///     }
/// }
/// ```
/// ```http
/// {
///   "Ok": "Привет, Мир!"
/// }
/// ```
/// #### №3
/// ``` http
/// POST /api/AffineCipherDecode
///
/// {
///     "input": "Cnwwl, Zlawi!",
///     "lang": "en",
///     "params": {
///         "a": -5,
///         "b": 12735073052703957225979
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 400 Bad Request
/// {
///   "Err": "Invalid value: integer `-5`, expected u8."
/// }
/// ```
pub struct AffineCipherDecode;

const NAME: &str = "AffineCipherDecode";
const DESCRIPTION_EN: &str = "The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.";
const DESCRIPTION_RU: &str = "Аффинный шифр — это тип моноалфавитного шифра замены. Чтобы расшифровать, каждая буква в алфавите сопоставляется с ее числовым эквивалентом, расшифровывается с помощью математической функции и преобразуется обратно в букву.";

const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Affine_cipher");

create_info_struct!(
    AffineCipherDecodeInfo,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
use crate::utils::modulus;
use crate::{
    create_info_struct, lang_me_daddy,
    traits::CharTrait,
    utils::{get_alphabet, get_char_by_index, get_index_by_char, validate_lang},
    Operation, DOCS_URL,
};
use num::Integer;
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, String> for AffineCipherEncode {
    fn run(&self, request: &str) -> Result<String, String> {
        let request = self.validate(request)?;

        let (input, lang, params) = (request.input, request.lang, request.params);
        if !validate_lang(&input, &lang) {
            return Err("Wrong language.".to_string());
        };

        let (a, b) = (params.a as i16, params.b as i16);

        let (alp_lower, alp_upper, alp_length, _) = get_alphabet(&lang);
        if a.gcd(&(alp_length as i16)) != 1 {
            return Err(format!(
                "The value of `a` must be coprime to alphabet length({}).",
                alp_length
            ));
        }

        let mut output = String::with_capacity(alp_length as usize);

        for c in input.chars() {
            if !c.is_alphabetic() {
                output.push(c);
                continue;
            }

            let x = match c.is_lowercase() {
                true => get_index_by_char(alp_lower, c),
                false => get_index_by_char(alp_upper, c),
            } as i16;

            let x = modulus(a * x + b, alp_length as i16);

            output.push(match c.is_lowercase() {
                true => get_char_by_index(alp_lower, x),
                false => get_char_by_index(alp_upper, x).to_upper_case(),
            });
        }

        Ok(output)
    }
}

#[derive(Deserialize)]
struct Params {
    a: u8,
    b: u8,
}

lang_me_daddy!();

/// The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.
/// <br><br/>
/// For more information go [here](https://wikipedia.org/wiki/Argon2)
/// <br><br/>
/// ### How to use
/// \
/// Send POST requests to /api/AffineCipherDecode with your data using json payload with this structure
/// ``` json
/// {
///     "input": string,
///     "params": {
///         "a": u8,
///         "b": u8,
///     }
/// }
/// ```
/// #### where
///     - u8 is unsigned 8-bit integer (digit between 0 and 255)
/// <br/><br/>
///
/// ### Server response have two possible formats
///
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
/// ``` json
/// { "Ok": `some answer` }
/// ```
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
/// ``` json
/// { "Err": `error message` }
/// ```
/// ### Examples
/// <br><br/>
/// #### №1
/// ``` http
/// POST /api/AffineCipherEncode
///
/// {
///     "input": "Hello, World!",
///     "lang": "en",
///     "params": {
///         "a": 5,
///         "b": 3
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 200 Ok
/// {
///   "Ok": "Mxggv, Jvkgs!"
/// }
/// ```
/// #### №2
/// ``` http
/// POST /api/AffineCipherEncode
///
/// {
///     "input": "Привет, Мир!",
///     "params": {
///         "a": 5,
///         "b" 3,
///     }
/// }
/// ```
/// ```http
/// {
///   "Ok": "Мскньы, Юкс!"
/// }
/// ```
/// #### №3
/// ``` http
/// POST /api/AffineCipherEncode
///
/// {
///     "input": "Hello, World!",
///     "lang": "en",
///     "params": {
///         "a": -5,
///         "b": 12735073052703957225979
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 400 Bad Request
/// {
///   "Err": "Invalid value: integer `-5`, expected u8."
/// }
/// ```
pub struct AffineCipherEncode;

const NAME: &str = "AffineCipherEncode";
const DESCRIPTION_EN: &str = "The Affine cipher is a type of monoalphabetic substitution cipher. To decrypt, each letter in an alphabet is mapped to its numeric equivalent, decrypted by a mathematical function, and converted back to a letter.";
const DESCRIPTION_RU: &str = "Аффинный шифр — это тип моноалфавитного шифра замены. Чтобы расшифровать, каждая буква в алфавите сопоставляется с ее числовым эквивалентом, расшифровывается с помощью математической функции и преобразуется обратно в букву.";

const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Affine_cipher");

create_info_struct!(
    AffineCipherEncodeInfo,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
use crate::{
    create_info_struct, create_me_daddy,
    utils::{from_base64, to_hex, DataRepresentation},
    Operation, DOCS_URL,
};
use argon2::{Config, ThreadMode, Variant, Version};
use serde::{Deserialize, Serialize};

impl Operation<'_, DeserializeMeDaddy, String> for Argon2 {
    fn run(&self, request: &str) -> Result<String, String> {
        let request = self.validate(request)?;

        let (params, input) = (request.params, request.input);

        let config = Config {
            variant: params.argon2_type,
            version: Version::Version13,
            mem_cost: params.memory,
            time_cost: params.iterations,
            lanes: params.parallelism,
            thread_mode: ThreadMode::Parallel,
            secret: &[],
            ad: &[],
            hash_length: params.hash_length,
        };

        let hash = argon2::hash_encoded(input.as_bytes(), params.salt.as_bytes(), &config).unwrap();

        let output = match params.output_format {
            OutputFormat::Encoded => hash,
            format => {
                let raw_hash = hash.split('$').nth(5).unwrap();

                let data = match from_base64(
                    raw_hash.to_string(),
                    "",
                    DataRepresentation::String(String::new()),
                    false,
                    false,
                ) {
                    Ok(DataRepresentation::String(data)) => data,
                    _ => unreachable!(),
                };

                match format {
                    OutputFormat::Hex => to_hex(data.as_bytes()),
                    OutputFormat::Raw => data,
                    _ => unreachable!(),
                }
            }
        };

        Ok(output)
    }
}

// region with structs and enums

#[derive(Deserialize)]
struct Params {
    salt: String,
    iterations: u32,
    memory: u32,
    parallelism: u32,
    hash_length: u32,
    #[serde(with = "MyVariant")]
    argon2_type: Variant,
    output_format: OutputFormat,
}

create_me_daddy!();

/// Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.
/// <br/>
/// For more information go [here](https://wikipedia.org/wiki/Argon2)
/// <br/><br/>
///
/// ### How to use
/// \
/// Send POST requests to /api/Argon2 with your data using json payload with this structure
/// ``` json
/// {
///     "input": string,
///     "params": {
///         "salt": string,
///         "iterations": u32,
///         "parallelism": u32,
///         "hash_length": u32,
///         "argon2_type": Argon2Type,
///         "output_format": OutputFormat,
///         "memory": u32
///     }
/// }
/// ```
/// #### where
///     - u32 is unsigned 32-bit integer
///     - Argon2Type is one of "Argon2i", "Argon2d", "Argon2id"
///     - OutputFormat is one of "Encoded", "Hex", "Raw"
/// <br/><br/>
///
/// ### Server response have two possible formats
///
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Ok variant
/// ``` json
/// { "Ok": `some answer` }
/// ```
/// #### &nbsp;&nbsp;&nbsp;&nbsp; Error variant
/// ``` json
/// { "Err": `error message` }
/// ```
/// ### Examples
/// <br><br/>
/// #### №1
/// ``` http
/// POST /api/Argon2
///
/// {
///     "input": "hello",
///     "params": {
///         "salt": "somesalt",
///         "iterations": 3,
///         "parallelism": 1,
///         "hash_length": 32,
///         "argon2_type": "Argon2i",
///         "output_format": "Encoded",
///         "memory": 4096
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 200 Ok
/// {
///   "Ok": "$argon2i$v=19$m=4096,t=3,p=1$c29tZXNhbHQ$WVDOfucSPAey3UEzzqLtBwRbGS83pTyIPLXgjhKfgrY"
/// }
/// ```
/// #### №2
/// ``` http
/// POST /api/Argon2
///
/// {
///     "input": "Привет, Мир!",
///     "params": {
///         "salt": "новая соль",
///         "iterations": 6,
///         "parallelism": 1,
///         "hash_length": 34,
///         "argon2_type": "Argon2id",
///         "output_format": "Hex",
///         "memory": 8096
///     }
/// }
/// ```
/// ```http
/// {
///   "Ok": "eb4140b78ed1c4fcd736c1b73cdf555ba244371ff53971e53823e411aeefbd60751d"
/// }
/// ```
/// #### №3
/// ``` http
/// POST /api/Argon2
/// content_type: application/json; charset=utf-8
///
/// {
///     "input": "error",
///     "params": {
///         "salt": "missing iterations parameter",
///         "parallelism": 1,
///         "hash_length": 34,
///         "argon2_type": "Argon2id",
///         "output_format": "Hex",
///         "memory": 8096
///     }
/// }
/// ```
/// ```http
/// HTTP/1.1 400 Bad Request
/// {
///   "Err": "missing field `iterations`"
/// }
/// ```
pub struct Argon2;

#[derive(Deserialize)]
#[serde(remote = "Variant")]
enum MyVariant {
    Argon2d = 0,
    Argon2i = 1,
    Argon2id = 2,
}

#[derive(Deserialize)]
enum OutputFormat {
    Encoded,
    Hex,
    Raw,
}

// endregion

// region info about operation

const NAME: &str = "Argon2";
const DESCRIPTION_EN: &str = "Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in July 2015. It was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich from the University of Luxembourg.<br><br>Enter the password in the input to generate its hash.";
const DESCRIPTION_RU: &str = "Argon2 – это функция получения ключа, которая была выбрана победителем конкурса хеширования паролей в июле 2015 года. Она была разработана Алексом Бирюковым, Даниэлем Дину и Дмитрием Ховратовичем из Люксембургского университета.<br><br>Введите пароль в ввод для генерации его хэша.";

const INFO_URL: Option<&str> = Some("https://wikipedia.org/wiki/Argon2");

create_info_struct!(
    Argon2Info,
    NAME,
    DOCS_URL,
    DESCRIPTION_EN,
    DESCRIPTION_RU,
    INFO_URL
);
pub trait CharTrait {
    fn to_lower_case(&self) -> Self;
    fn to_upper_case(&self) -> Self;
}

impl CharTrait for char {
    fn to_lower_case(&self) -> char {
        match self {
            'A'..='Z' => self.to_ascii_lowercase(),
            'А'..='Я' => char::from_u32(*self as u32 + 32).unwrap(),
            'Ё' => char::from_u32(*self as u32 + 80).unwrap(),
            _ => *self,
        }
    }

    fn to_upper_case(&self) -> char {
        match self {
            'a'..='z' => self.to_ascii_lowercase(),
            'а'..='я' => char::from_u32(*self as u32 - 32).unwrap(),
            'ё' => char::from_u32(*self as u32 - 80).unwrap(),
            _ => *self,
        }
    }
}

pub trait StringTrait {
    fn regex_replace_all(&self, regex: &str, replacement: &str) -> Result<String, String>;
    fn regex_replace(&self, regex: &str, replacement: &str) -> Result<String, String>;

    fn capitalize(&self) -> String;
}

impl StringTrait for String {
    fn regex_replace_all(&self, regex_str: &str, replacement: &str) -> Result<String, String> {
        let Ok(re) = regex::Regex::new(regex_str) else {
            return Err(String::from("wrong regex"));
        };
        let output: String = re.replace_all(regex_str, replacement).to_string();
        Ok(output)
    }

    fn regex_replace(&self, regex_str: &str, replacement: &str) -> Result<String, String> {
        let Ok(re) = regex::Regex::new(regex_str) else {
            return Err(String::from("wrong regex"));
        };

        let output: String = re.replace(regex_str, replacement).to_string();
        Ok(output)
    }
    fn capitalize(&self) -> String {
        let mut c = self.chars();
        match c.next() {
            None => String::new(),
            Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
        }
    }
}
use crate::{map, regex_check, traits::StringTrait};
use encoding_rs::UTF_8_INIT;
use itertools::Itertools;
use num::{FromPrimitive, Integer, ToPrimitive};
use unicode_segmentation::UnicodeSegmentation;

// region constants

#[derive(Eq, PartialEq)]
pub enum DataRepresentation {
    String(String),
    ByteArray(Vec<u8>),
}

pub const EN_ALP: (&str, &str, u8, &str) = (
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    26,
    r"^[a-zA-Z]+$",
);
pub const RU_ALP: (&str, &str, u8, &str) = (
    "абвгдежзийклмнопрстуфхцчшщъыьэюя",
    "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",
    33,
    "^[а-яА-Я]+$",
);
pub const RU_ALP_WITH_YO: (&str, &str, u8, &str) = (
    "абвгдеёжзийклмнопрстуфхцчшщъыьэюя",
    "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ",
    33,
    r"^[а-яА-ЯёЁ]+$",
);
pub const NUM: (&str, &str) = ("0123456789", r"^\+?(0|[1-9]\d*)$");

// endregion

// region work with strings

pub fn expand_alphabet_range(alphabet: &str) -> Vec<char> {
    let mut result: Vec<char> = Vec::new();
    let alphabet_length = alphabet.graphemes(true).count();
    let mut i = 0;

    while i < alphabet_length {
        let by_index = get_char_by_index(alphabet, i);
        if (i < alphabet_length - 2)
            && (get_char_by_index(alphabet, i + 1) == '-')
            && (by_index != '\\')
        {
            let (start, end) = (ord(by_index), ord(get_char_by_index(alphabet, i + 2)));

            for j in start..=end {
                result.push(chr(j));
            }
            i += 2;
        } else if (i < alphabet_length - 2)
            && (by_index == '\\')
            && (get_char_by_index(alphabet, i + 1) == '-')
        {
            result.push('-');
            i += 1;
        } else {
            result.push(by_index);
        }
        i += 1;
    }

    result
}

pub fn str_to_array_buffer(string: &str) -> Vec<u32> {
    if string.is_empty() {
        return Vec::new();
    }

    let string_length = string.graphemes(true).count();
    let mut result: Vec<u32> = vec![0; string_length];

    for (idx, elem) in result.iter_mut().enumerate() {
        *elem = ord(get_char_by_index(string, idx));
    }

    result
}

pub fn str_to_array_buffer_by_alphabet(string: &str, alphabet: &str) -> Vec<usize> {
    if string.is_empty() {
        return Vec::new();
    }

    let string_length = string.graphemes(true).count();
    let mut result: Vec<usize> = vec![0; string_length];
    for (idx, c) in string.chars().enumerate() {
        result[idx] = get_index_by_char(alphabet, c);
    }

    result
}

pub fn byte_array_to_chars(byte_array: Vec<u8>) -> Result<String, String> {
    String::from_utf8(byte_array).map_err(|err| err.to_string())
}

pub fn convert_to_byte_string(string: &str, convert_type: &str) -> Result<String, String> {
    match &*convert_type.to_lowercase() {
        "binary" => match from_binary(string, None, None) {
            Ok(data) => byte_array_to_chars(data),
            Err(e) => Err(e.to_string()),
        },
        "hex" => match from_hex(string, None, None) {
            Ok(data) => byte_array_to_chars(data),
            Err(e) => Err(e.to_string()),
        },
        "decimal" => match from_decimal(string, None) {
            Ok(data) => {
                let mut new_data = Vec::with_capacity(data.len());
                for elem in data.iter() {
                    match u8::from_usize(*elem) {
                        Some(val) => new_data.push(val),
                        None => return Err("a".to_string()),
                    };
                }
                byte_array_to_chars(new_data)
            }
            Err(e) => Err(e.to_string()),
        },
        "base64" => match from_base64(
            string.to_string(),
            "",
            DataRepresentation::ByteArray(Vec::new()),
            true,
            false,
        ) {
            Ok(data) => {
                let DataRepresentation::ByteArray(data) = data else {
                    unreachable!()
                };
                byte_array_to_chars(data)
            }
            Err(e) => Err(e.to_string()),
        },
        "utf8" | "utf-8" => match String::from_utf8(UTF_8_INIT.encode(string).0.into()) {
            Ok(data) => Ok(data),
            Err(e) => Err(e.to_string()),
        },
        "latin1" => unimplemented!(),
        _ => Ok(String::new()),
    }
}

pub fn from_binary(
    data: &str,
    delim: Option<&str>,
    byte_len: Option<usize>,
) -> Result<Vec<u8>, String> {
    if byte_len.unwrap_or(8) < 1 {
        return Err("Byte length must be a positive integer".to_string());
    };

    let delim = char_repr(delim.unwrap_or("Space"));
    let data = data.replace(delim, " ");

    let mut output: Vec<u8> = Vec::new();
    for i in data.split_whitespace() {
        match u8::from_str_radix(i, 2) {
            Ok(data) => output.push(data),
            Err(e) => return Err(e.to_string()),
        }
    }

    Ok(output)
}

pub fn to_hex(data: &[u8]) -> String {
    data.iter()
        .fold(String::new(), |out, x| format!("{out}{:x}", x))
}

pub fn from_hex(
    data: &str,
    delim: Option<&str>,
    byte_len: Option<usize>,
) -> Result<Vec<u8>, String> {
    if byte_len.unwrap_or(8) < 1 {
        return Err("Byte length must be a positive integer".to_string());
    }

    let mut output: Vec<u8> = Vec::new();
    let delim = char_repr(delim.unwrap_or("Space"));

    for i in data.split(&delim) {
        match u8::from_str_radix(i, 16) {
            Ok(data) => output.push(data),
            Err(e) => return Err(e.to_string()),
        }
    }

    Ok(output)
}

pub fn from_decimal(data: &str, delim: Option<&str>) -> Result<Vec<usize>, String> {
    let mut output = Vec::new();
    for i in data.split(char_repr(delim.unwrap_or("Space"))) {
        match i.parse::<usize>() {
            Ok(data) => output.push(data),
            Err(e) => return Err(e.to_string()),
        }
    }
    Ok(output)
}

pub fn to_base64(data: &str, mut alphabet: &str) -> Result<String, String> {
    if data.is_empty() {
        return Ok(String::new());
    }
    if alphabet.is_empty() {
        alphabet = "A-Za-z0-9+/=";
    }

    let alphabet = expand_alphabet_range(alphabet).iter().collect::<String>();

    let alphabet_length = alphabet.graphemes(true).count();

    if alphabet_length != 64 && alphabet_length != 65 {
        return Err("Invalid base64 alphabet length".to_string());
    }

    let mut output = String::new();
    let mut padding = 0;

    for i in str_to_array_buffer(data)
        .iter()
        .fold(String::new(), |acc, x| acc + &format!("{:08b}", x))
        .chars()
        .chunks(6)
        .into_iter()
        .map(|x| {
            let sextet = x.collect::<String>();
            match sextet.len() {
                6 => u8::from_str_radix(&sextet, 2),
                _ => {
                    padding += 1;
                    u8::from_str_radix(&format!("{:0<6}", sextet), 2)
                }
            }
            .unwrap()
        })
    {
        output.push(get_char_by_index(&alphabet, i))
    }

    output.push_str(&match alphabet_length {
        65 => get_char_by_index(&alphabet, 64).to_string().repeat(padding),
        _ => "".to_string(),
    });

    Ok(output)
}
pub fn from_base64(
    mut data: String,
    mut alphabet: &str,
    return_type: DataRepresentation,
    remove_non_alp_chars: bool,
    strict_mode: bool,
) -> Result<DataRepresentation, String> {
    if data.is_empty() {
        return match return_type {
            DataRepresentation::String(_) => Ok(DataRepresentation::String(String::new())),
            DataRepresentation::ByteArray(_) => Ok(DataRepresentation::ByteArray(Vec::new())),
        };
    }
    if alphabet.is_empty() {
        alphabet = "A-Za-z0-9+/=";
    }

    {
        let regex = regex::Regex::new(&format!("[{}]", alphabet)).unwrap();
        if !regex.is_match(&data) {
            return Err("Invalid base64 alphabet".to_string());
        }
    }

    let alphabet = expand_alphabet_range(alphabet).iter().collect::<String>();
    let alphabet_length = alphabet.graphemes(true).count();

    if alphabet_length != 64 && alphabet_length != 65 {
        return Err("Invalid base64 alphabet length".to_string());
    }

    if remove_non_alp_chars {
        let re = format!(
            "[^{}]",
            alphabet.regex_replace_all(r"[\[\]\\\-^$]", r"\$&").unwrap()
        );
        data = data.regex_replace_all(&re, "").unwrap();
    }

    if strict_mode {
        if data.len() % 4 == 1 {
            return Err(format!(
                "Invalid Base64 input length ({}) cannot be 4n+1, even without padding chars.",
                data.len()
            ));
        }

        if alphabet_length == 65 {
            let pad = get_char_by_index(&alphabet, 64);
            let pad_pos = data.find(pad);

            if let Some(pad_pos) = pad_pos {
                if pad_pos < data.len() - 2 || get_char_by_index(&data, data.len() - 1) != pad {
                    return Err(
                        "Base64 padding character ({pad}) not used in the correct place."
                            .to_string(),
                    );
                }

                if data.len() % 4 != 0 {
                    return Err("Base64 not padded to a multiple of 4.".to_string());
                }
            }
        }
    }
    if alphabet_length == 65 {
        data = data
            .trim_end_matches(get_char_by_index(&alphabet, 64))
            .to_string();
    }

    return match return_type {
        DataRepresentation::String(_) => {
            let mut output = String::new();
            str_to_array_buffer_by_alphabet(&data, &alphabet)
                .iter()
                .map(|x| format!("{:08b}", x)[2..].to_string())
                .collect::<String>()
                .chars()
                .chunks(8)
                .into_iter()
                .map(|x| u8::from_str_radix(&x.collect::<String>(), 2).unwrap() as char)
                .for_each(|x| output.push(x));

            Ok(DataRepresentation::String(output))
        }
        DataRepresentation::ByteArray(_) => {
            let mut output = Vec::new();

            str_to_array_buffer_by_alphabet(&data, &alphabet)
                .iter()
                .map(|x| format!("{:08b}", x)[2..].to_string())
                .collect::<String>()
                .chars()
                .chunks(8)
                .into_iter()
                .map(|x| u8::from_str_radix(&x.collect::<String>(), 2).unwrap())
                .for_each(|x| output.push(x));

            Ok(DataRepresentation::ByteArray(output))
        }
    };
}

pub fn validate_lang(text: &str, lang: &str) -> bool {
    let re = match lang {
        "en" => r"^[a-zA-Z\p{P}\s\d]+$",
        "ru" => r"^[а-яА-Я\p{P}\s\d]+$",
        "ru_with_yo" => r"^[а-яА-ЯёЁ\p{P}\s\d]+$",
        _ => return false,
    };
    regex_check!(re => text)
}

pub fn get_alphabet(lang: &str) -> (&'static str, &'static str, u8, &'static str) {
    match lang {
        "en" => EN_ALP,
        "ru" => RU_ALP,
        "ru_with_yo" => RU_ALP_WITH_YO,
        _ => EN_ALP,
    }
}

pub fn get_char_by_index<T: Integer + ToPrimitive>(text: &str, index: T) -> char {
    text.chars().nth(index.to_usize().unwrap()).unwrap()
}

pub fn get_index_by_char(text: &str, ch: char) -> usize {
    text.chars().position(|c| c == ch).unwrap()
}

pub fn char_repr(token: &str) -> &str {
    map!(
        "Space" => " ",
        "Percent" => "%",
        "Comma" => ",",
        "Semi-colon" => ";",
        "Colon" => ":",
        "Tab" => "\t",
        "Line feed" => "\n",
        "CRLF" => "\r\n",
        "Forward slash" => "/",
        "Backslash" => "\\",
        "0x" => "0x",
        "\\x" => "\\x",
        "Nothing (separate chars)" => "",
        "None" => "",
    )
    .get(token)
    .unwrap_or(&" ")
}

pub fn chr(code: u32) -> char {
    char::from_u32(code).unwrap()
}

pub fn ord(chr: char) -> u32 {
    chr as u32
}

// endregion

// region math

pub fn update_step<T: Integer + Copy>(a: &mut T, old_a: &mut T, quotient: T) {
    let temp = *a;
    *a = *old_a - quotient * temp;
    *old_a = temp;
}

pub fn extended_gcd<T: Integer + Copy>(a: T, b: T) -> (T, T, T) {
    let (mut old_r, mut rem) = (a, b);
    let (mut old_s, mut coefficient_s) = (T::one(), T::zero());
    let (mut old_t, mut coefficient_t) = (T::zero(), T::one());

    while rem != T::zero() {
        let quotient = old_r / rem;

        update_step(&mut rem, &mut old_r, quotient);
        update_step(&mut coefficient_s, &mut old_s, quotient);
        update_step(&mut coefficient_t, &mut old_t, quotient);
    }

    (old_r, old_s, old_t)
}

pub fn mod_inv<T: Integer + Copy>(a: T, module: T) -> T {
    let (_, x, _) = extended_gcd(a, module);

    if x < T::zero() {
        x + module
    } else {
        x
    }
}

pub fn modulus<T: Integer + Copy>(x: T, y: T) -> T {
    ((x % y) + y) % y
}

pub fn add(a: i16, b: i16) -> i16 {
    a + b
}

pub fn sub(a: i16, b: i16) -> i16 {
    a - b
}

// endregion
extern crate core;

pub mod libs;
mod macros;
mod operations;
pub mod traits;
pub mod utils;

pub use operations::a1z26cipher_decode_mod::{A1Z26CipherDecode, A1Z26CipherDecodeInfo};
pub use operations::a1z26cipher_encode_mod::{A1Z26CipherEncode, A1Z26CipherEncodeInfo};
pub use operations::affine_cipher_decode_mod::{AffineCipherDecode, AffineCipherDecodeInfo};
pub use operations::affine_cipher_encode_mod::{AffineCipherEncode, AffineCipherEncodeInfo};
pub use operations::analyse_hash_mod::{AnalyseHash, AnalyseHashInfo};
pub use operations::argon2_mod::{Argon2, Argon2Info};

use crate::traits::StringTrait;
use serde::{Deserialize, Serialize};

const DOCS_URL: &str = "soon I transfer all documentation to somewhere :/";

pub trait Operation<'a, I, O>
where
    I: Deserialize<'a>,
{
    fn run(&self, request: &str) -> Result<O, String>;
    fn validate(&self, request: &'a str) -> Result<I, String> {
        self.deserialize(request)
    }

    fn deserialize(&self, request: &'a str) -> Result<I, String> {
        serde_json::from_str(request).map_err(|err| match err.to_string() {
            err if err.starts_with("unknown")
                || err.starts_with("missing")
                || err.starts_with("invalid") =>
            {
                err.split(" at line ")
                    .next()
                    .unwrap()
                    .to_string()
                    .capitalize()
                    + "."
            }
            err => err.capitalize() + ".",
        })
    }
}

#[derive(Serialize, Deserialize)]
pub enum Operations {
    A1Z26CipherDecode,
    A1Z26CipherEncode,
    AffineCipherDecode,
    AffineCipherEncode,
    AnalyseHash,
    Argon2,
}
#[macro_export]
macro_rules! map {
    ($($k:expr => $v:expr),* $(,)?) => {{
        let mut m = std::collections::HashMap::new();
        $(m.insert($k, $v);)*
        m
    }};
}

#[macro_export]
macro_rules! regex_check {
    ($regex:expr => $string:expr) => {{
        let regex = regex::Regex::new($regex).unwrap();
        regex.is_match($string)
    }};
}

#[macro_export]
macro_rules! create_me_daddy {
    () => {
        #[derive(Deserialize)]
        pub struct DeserializeMeDaddy {
            input: String,
            params: Params,
        }
    };
}

#[macro_export]
macro_rules! lang_me_daddy {
    () => {
        #[derive(Deserialize)]
        pub struct DeserializeMeDaddy {
            input: String,
            lang: String,
            params: Params,
        }
    };
}

#[macro_export]
macro_rules! create_info_struct {
    ($struct_name:ident, $name:ident, $doc:ident, $description_en:ident, $description_ru:ident, $info_url:ident) => {
        #[derive(Serialize)]
        pub struct $struct_name {
            name: &'static str,
            documentation: &'static str,
            description_en: &'static str,
            description_ru: &'static str,
            info_url: Option<&'static str>,
        }

        impl $struct_name {
            pub fn info() -> String {
                let structure = Self {
                    name: $name,
                    documentation: $doc,
                    description_en: $description_en,
                    description_ru: $description_ru,
                    info_url: $info_url,
                };
                serde_json::to_string(&structure).unwrap()
            }
        }
    };
}
mod config;

use actix_web::web::post;
use actix_web::{
    http::StatusCode,
    middleware::Logger,
    post,
    web::{resource, Path},
    App, HttpResponse, HttpServer,
};
use ciphers::{self, *};
use serde::{Deserialize, Serialize};

// black magic with generic
fn http_response<'a, I, O, T: Operation<'a, I, O>>(structure: T, body: String) -> HttpResponse
where
    I: Deserialize<'a>,
    O: Serialize,
{
    let data = structure.run(&body);
    HttpResponse::build(if data.is_ok() {
        StatusCode::OK
    } else {
        StatusCode::BAD_REQUEST
    })
    .append_header(("Access-Control-Allow-Origin", "*"))
    .json(data)
}

#[post("/api/{name}")]
async fn ciphers_handler(body: String, name: Path<Operations>) -> HttpResponse {
    match name.into_inner() {
        Operations::A1Z26CipherDecode => http_response(A1Z26CipherDecode, body),
        Operations::A1Z26CipherEncode => http_response(A1Z26CipherEncode, body),
        Operations::AffineCipherDecode => http_response(AffineCipherDecode, body),
        Operations::AffineCipherEncode => http_response(AffineCipherEncode, body),
        Operations::AnalyseHash => http_response(AnalyseHash, body),
        Operations::Argon2 => http_response(Argon2, body),
    }
}

async fn ciphers_info_handler(name: Path<Operations>) -> HttpResponse {
    let response = match name.into_inner() {
        Operations::Argon2 => Argon2Info::info(),
        Operations::A1Z26CipherDecode => A1Z26CipherDecodeInfo::info(),
        Operations::A1Z26CipherEncode => A1Z26CipherEncodeInfo::info(),
        Operations::AffineCipherDecode => AffineCipherDecodeInfo::info(),
        Operations::AffineCipherEncode => AffineCipherEncodeInfo::info(),
        Operations::AnalyseHash => AnalyseHashInfo::info(),
    };

    HttpResponse::build(StatusCode::OK)
        .append_header(("Access-Control-Allow-Origin", "*"))
        .content_type("application/json")
        .body(response)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));
    HttpServer::new(|| {
        let logger = Logger::default();

        App::new().wrap(logger).service(ciphers_handler).service(
            resource(vec!["/api/{name}/help", "/api/{name}/info"])
                .route(post().to(ciphers_info_handler))
                .route(post().to(ciphers_info_handler)),
        )
    })
    .bind(config::HOSTNAME)?
    .run()
    .await
}
use std::net::{Ipv4Addr, SocketAddrV4};

pub const HOSTNAME: SocketAddrV4 = SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 8081);
FROM rust

WORKDIR /app

COPY . .
RUN cargo build -p backend --release
EXPOSE 8081
ENTRYPOINT ["./target/release/backend"]services:
  CyberKnight:
    build:
      context: .
      dockerfile: backend
    image: cyber_knight
    container_name: cyber_knight
    ports:
      - "8081:8081"
    restart: unless-stopped

networks:
  default:
    driver: bridge
    name: cyber_knight
[package]
name = "cyber_knight"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4.3.1"
serde = { version = "1.0.171", features = ["derive"] }
serde_json = "1.0.103"
env_logger = "0.10.0"

ciphers = { path = "ciphers" }

[workspace]
members = [
    "frontend",
    "ciphers"
]

[profile.release]
opt-level = "s"
nothing to see here

*right now# CyberKnight